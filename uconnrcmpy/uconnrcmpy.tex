% !TEX option = -shell-escape
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This work is licensed under the Creative Commons Attribution 4.0
% International License. To view a copy of this license, visit
% http://creativecommons.org/licenses/by/4.0/.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt]{../ussci}

\usepackage{enumitem}
\setlist{noitemsep}

\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{microtype}

% Fix missing mu character from a reference
\usepackage{textcomp}
\DeclareUnicodeCharacter{3BC}{\textmu}
\DeclareUnicodeCharacter{39C}{\textmu}

\usepackage[capitalize]{cleveref}
%======================================================================
\addbibresource[location=remote]{http://localhost:23119/better-bibtex/collection?/0/2017-National-Combustion-Meeting/UConnRCMPy.biblatex}
%======================================================================
\newcommand\papertopic{Reaction Kinetics}
%======================================================================
\DeclareSIUnit\torr{torr}

\title{ UConnRCMPy: Python-based data analysis for Rapid Compression Machines }

\author[1*]{Bryan W.\ Weber}
\author[1]{Chih-Jen Sung}
\affil[1]{Department of Mechanical Engineering, University of Connecticut, Storrs,
CT, USA}
\affil[*]{Corresponding Author: \email{bryan.weber@uconn.edu}}

\begin{document}
\maketitle

%====================================================================
\begin{abstract} % not to exceed 200 words
    The ignition delay of a fuel/air mixture is an important quantity in
    designing combustion devices, and these data are also used to validate
    computational kinetic models for combustion. One of the typical
    experimental devices used to measure the ignition delay is called a
    Rapid Compression Machine (RCM). This paper presents UConnRCMPy, an
    open-source Python package to process experimental data from the RCM at
    the University of Connecticut. Given an experimental measurement,
    UConnRCMPy computes the thermodynamic conditions in the reaction chamber
    of the RCM during an experiment along with the ignition delay.
    UConnRCMPy relies on several packages from the SciPy stack and the
    broader scientific Python community. UConnRCMPy implements an extensible
    framework, so that alternative experimental data formats can be
    incorporated easily. In this way, UConnRCMPy improves the consistency of
    RCM data processing and enables reproducible analysis of the data.
\end{abstract}

% (Provide 2-4 keywords describing your research. Only abbreviations firmly
% established in the field may be used. These keywords will be used for
% sessioning/indexing purposes.)
\begin{keyword}
    chemical kinetics\sep rapid compression machine\sep reproducibility
\end{keyword}

\section{Introduction}\label{introduction}

Producing research outputs that can be reproduced by future scientists is one of
the fundamental tenents of our present scientific methodology. In recent years,
there has been a surge in interest in ensuring that research outputs are
reproducible \autocite{NatureEds2016}. Recognizing that the code used to process
experimental data is an important part of the chain, this paper presents the
design and operation of a software package to process the pressure data
collected from Rapid Compression Machines (RCMs). Our package, called UConnRCMPy
\autocite{uconnrcmpy}, is designed to analyze the data acquired from the RCM at
the University of Connecticut (UConn). Despite the initial focus on data from
the UConn RCM, the package is designed to be extensible so that it can be used
for data in different formats while providing a consistent interface to the
user. Thus, UConnRCMPy offers all of the features required to process standard
RCM data including:

\begin{itemize}
\item
  Filtering and smoothing the raw voltage generated by the pressure
  transducer
\item
  Converting the voltage trace into a pressure trace using settings
  recorded from the RCM
\item
  Processing the pressure trace to determine parameters of interest in
  reporting the experiments, including the ignition delay and
  machine-specific effects on the experiment
\item
  Conducting simulations utilizing the experimental information to
  calculate the temperature during the experiment
\end{itemize}

Previous software used to analyze RCM data has generally been
undocumented and untested code specific to the researcher conducting the
experiments. Moreover, the software typically used to estimate the
temperature in the experiments is difficult to integrate with the data
processing code. To the best of the authors' knowledge, UConnRCMPy is
the first package for analysis of standard RCM data to be presented in
detail in the literature, and it tightly integrates the temperature
estimation routine into the workflow, reducing errors and
inefficiencies.

\section{RCM Signal Processing Procedure}\label{rcm-signal-processing-procedure}

\subsection{Signal measurement}\label{signal-measurement}

The RCMs at the University of Connecticut have been described extensively
elsewhere \autocite{Das2012,Mittal2007a}, and interested readers are directed to
those papers for further details. The primary diagnostic on the RCM is the
reaction chamber pressure during and after the compression process, measured by
a dynamic pressure transducer. The pressure trace is processed to determine the
quantities of interest, including the pressure and temperature at the EOC,
\(P_C\) and \(T_C\) respectively, and the ignition delay, \(\tau\). These values
depend on the pressure and temperature prior to the start of compression
(\(P_0\) and \(T_0\), respectively), in addition to the composition of the
reactant mixture. A single compression-delay-ignition sequence is
referred to as an experiment or a run. Each experiment is repeated
approximately 5 times at the same nominal initial conditions to ensure
repeatability of the data, and this set of experiments is referred to in
the following as a condition.

The dynamic pressure transducer outputs a charge signal that is converted to a
voltage signal by a charge amplifier with a nominal output of \SI{0}{\V} prior
to the start of compression. In addition, the output range of
\SIrange{0}{10}{\V} is set by the operator to correspond to a particular
pressure range by setting a ``scale factor''. Typical values for the scale
factor range between \SIrange[range-phrase={ and }]{10}{100}{\bar\per\V}. The
voltage output from the charge amplifier is digitized by a hardware data
acquisition system (DAQ) and recorded into a plain text file by a LabView
Virtual Instrument. The voltage is sampled at a rate chosen by the operator,
typically between \SIrange[range-phrase={ and }]{50}{100}{\kHz}. This provides
sufficient resolution for events on the order of milliseconds; the typical
ignition delay measured with this RCM approximately ranges from
\SIrange{5}{100}{\ms}.

\begin{figure}[htbp]
    \begin{minipage}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/raw-voltage.pdf}
        \caption{Raw voltage trace and the voltage trace after filtering from a typical
        RCM experiment. (a): Close up of the
        time around the EOC (b): Close up of the time before the start of
        compression}
        \label{fig:raw-voltage}
    \end{minipage}\hfill%
    \begin{minipage}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/residuals.pdf}
        \caption{Root mean squared residuals of the filtered signal compared to the
        original signal for a range of filter cutoff frequencies}
        \label{fig:residuals}
    \end{minipage}
\end{figure}

\Cref{fig:raw-voltage} shows a typical voltage trace measured from the RCM at
UConn. Several features are apparent from this figure. First, the compression
stroke takes approximately \SIrange{30}{40}{\ms} and approximately
\SI{50}{\percent} of the pressure rise occurs in the last \SI{5}{\ms} of
compression. Second, there is a slow pressure decrease after the EOC due to
heat transfer from the reactants to the relatively colder chamber walls. Third,
after some delay period there is a spike in the pressure corresponding to rapid
heat release due to combustion. Finally, the signal can be somewhat noisy,
requiring filtering and/or smoothing to produce a useful pressure trace.

\subsection{Filtering and Smoothing}\label{filtering-and-smoothing}

In the current version of UConnRCMPy \autocite{uconnrcmpy}, the voltage is
filtered using a first-order Butterworth filter. The cutoff frequency of the
filter is chosen automatically by a procedure described in the work of
\textcite{Yu1999}. Briefly, this procedure applies low-pass filters of
varying cutoff frequencies to the signal and calculates the root mean square
residual between the filtered signal and the original signal.
\Cref{fig:residuals} shows a typical plot of the residuals versus the cutoff
frequency and demonstrates that the residuals are nearly linear for a range of
cutoff frequencies. This range tends to be start at one-twentieth the Nyquist
frequency but the end point is variable. Therefore, a series of linear
regressions are performed as the end point is shifted from one-half the
Nyquist frequency to one-tenth the Nyquist frequency. Then, the $y$-intercept
of the regression with the highest coefficient of determination is used to
choose the optimal cutoff frequency. The optimum cutoff frequency is chosen as
the frequency at the intersection of the $y$-intercept and the residuals curve.
In practice, this is accomplished by shifting the residuals curve down
by the intercept and fitting a \python|UnivariateSpline| from the
\python|scipy.interpolate| module \autocite{Jones2001} to the
shifted residuals curve. The spline is fit such that it passes through every
point in the residuals. The root of the spline is then where the intercept
crosses the curve. The result of the filtering operation is shown on
\cref{fig:raw-voltage}.

\subsection{Offset Correction and Pressure Calculation}\label{offset-correction-and-pressure-calculation}

In general, the voltage trace can be converted to a pressure trace by
%
\begin{equation}
    P(t) = F \cdot \overline{V}(t) + P_0
\end{equation}
%
where \(\overline{V}(t)\) is the filtered and smoothed voltage trace and
\(F\) is the scale factor from the charge amplifier. However, as can be
seen in \cref{fig:raw-voltage}~b there is a small offset
in the initial voltage relative to the nominal value of \SI{0}{\V}. To correct
for this offset, it can be subtracted from the voltage trace
%
\begin{equation}
    P(t) = F \cdot \left[\overline{V}(t) - \overline{V}(0)\right] + P_0
\end{equation}
%
where \(\overline{V}(0)\) is the initial voltage of the filtered and
smoothed signal. Assuming the noise in the signal has an equal
probability of being above or below the mean voltage, choosing the
initial point (i.e., \(\overline{V}(0)\)) to set the voltage offset is
equivalent to choosing any other point prior to the start of
compression. The result is a vector of pressure values that must be
further processed to determine the time of the EOC and the ignition
delay.

\subsection{Finding the EOC}\label{finding-the-eoc}

In the current version of UConnRCMPy \autocite{uconnrcmpy}, the EOC is
determined by finding the local maximum of the pressure prior to
ignition. This is done by searching backwards in time from the global
maximum pressure in the pressure trace (typically, the global maximum of
the pressure is due to ignition) until a minimum in the pressure is
reached. The maximum of the pressure in points to the left of the minimum
is defined as the EOC. The value of the pressure at the EOC, \(P_C\), is
recorded and the time at the EOC is taken to be \(t=\SI{0}{\s}\).

\subsection{Calculating Ignition Delay}\label{calculating-ignition-delay}

The ignition delay is determined as the time difference between the EOC
and the point of ignition, defined as the inflection point in the pressure
trace due to ignition. The inflection point is found by the maximum
of the first derivative of the pressure with respect to time.
In the current version of UConnRCMPy \autocite{uconnrcmpy}, the first
derivative of the experimental pressure trace is computed by a
second-order forward differencing method. The derivative is then
smoothed by a moving average algorithm with a width of 151 points.
This value for the moving average window was chosen empirically.

For some conditions, the reactants may undergo two distinct stages of
ignition. These cases can be distinguished by a pair of peaks in the
first time derivative of the pressure. For some two-stage ignition
cases, the first-stage pressure rise, and consequently the peak in the
derivative, are relatively weak, making it hard to distinguish the peak
due to ignition from the background noise. This is currently the area
requiring the most manual intervention, and one area where significant
improvements can be made by refining the differentiation and
filtering algorithms. An experiment that shows two clear peaks
in the derivative is shown in \cref{fig:ign-delay-def} to
demonstrate the definition of the ignition delays.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/ign-delay-def.pdf}
    \caption{Illustration of the definition of the ignition delay in a
    two-stage ignition case}
    \label{fig:ign-delay-def}
\end{figure}

\subsection{Calculating the EOC Temperature}\label{calculating-the-eoc-temperature}

The final parameter of interest presently is the EOC temperature,
\(T_C\). This temperature is often used as the reference temperature
when reporting ignition delays. In general, it is difficult to measure
the temperature as a function of time in the reaction chamber of the
RCM, so methods to estimate the temperature from the pressure trace are
used. The detailed procedure used in UConnRCMPy is described in the work
of \textcite{Dames2016}, and an overview is given here.

In general, the temperature in the RCM reaction chamber as a function of
time can be found by integrating the first law of thermodynamics for an
ideal gas:
%
\begin{equation} \label{eq:first-law}
    c_v \frac{dT}{dt} = -P \frac{dv}{dt} - \sum_k u_k \frac{d Y_k}{dt}
\end{equation}
%
where \(c_v\) is the specific heat at constant volume of the mixture,
\(v\) is the specific volume, \(u_k\) and \(Y_k\) are the specific
internal energy and mass fraction of the species \(k\), and \(t\) is
time. In UConnRCMPy, \cref{eq:first-law} is integrated by Cantera
\autocite{cantera}.

Integrating \cref{eq:first-law} requires knowledge of the
volume of the reaction chamber as a function of time. To calculate the
volume as a function of time, it is assumed that there is a core of gas
in the reaction chamber that undergoes an isentropic, constant composition,
compression \autocite{Lee1998}. The initial entropy of the gas mixture is
calculated using Cantera \autocite{cantera}. Subsequently, the state of the
mixture is fixed by using the entropy and measured pressure; from this
information, the volume is calculated. The initial volume is
arbitrarily taken to be \(V_0=\SI{1.0}{\m\cubed}\). The initial volume used
in constructing the volume trace is arbitrary provided that the same
value is used for the initial volume in the simulations described below.
However, extensive quantities such as the total heat release during
ignition cannot be compared to experimental values.

Two simulations can be triggered by the user that solve \cref{eq:first-law}.
In the first, the multiplier for all the reaction rates is
set to zero, to simulate a constant composition (non-reactive) process.
In the second, the reactions are allowed to proceed as normal. Only the
non-reactive simulation is necessary to determine \(T_C\), which is
defined as the simulated temperature at the EOC time.

When a reactive simulation is conducted, the user must compare the
temperature traces from the two simulations to verify that the inclusion
of the reactions does not change \(T_C\), validating the assumption of
adiabatic, constant composition compression. Although including
reactions during the compression stroke does not affect the value of
\(T_C\), it does allow for the buildup of a small pool of radicals that
can affect processes after the EOC \autocite{Mittal2008}. Thus, it is
critical to include reactions during the compression stroke when
conducting simulations to compare a kinetic model to experimental
results.

\subsection{Simulating Post-EOC Processes}\label{simulating-post-eoc-processes}

As can be seen in \cref{fig:ign-delay-def}, the pressure
decreases after the EOC due to heat transfer from the higher temperature
reactants to the reaction chamber walls. This process is specific to the
machine that carried out the experiments, and to the conditions under
which the experiment was conducted. To include the effect of this heat
transfer into simulations, a non-reactive experiment is conducted, where
\(\text{O}_2\) in the oxidizer is replaced with \(\text{N}_2\).

To apply the effect of the post-compression heat loss into the
simulations, the reaction chamber is modeled as undergoing an adiabatic
volume expansion after EOC. Since the post-compression time is modeled as an
isentropic expansion, the same procedure is used as in the computation
of \(T_C\) to compute a volume trace for the post-EOC time. The only
difference is that the non-reactive pressure trace is used after the EOC
instead of the reactive pressure trace. Once the volume trace is
generated, it can be applied to a simulation by concatenating the volume
trace of the compression stroke and the post-EOC volume trace together
and following the procedure outlined in \cref{calculating-the-eoc-temperature}.
This procedure has been validated experimentally by measuring the temperature
in the reaction chamber during and after the compression stroke. The
temperature of the reactants was found to be within $\pm\sim $\SI{5}{\K} of the
simulated temperature \autocite{Das2012a,Uddi2012}.

\section{Implementation of UConnRCMPy}\label{implementation-of-uconnrcmpy}

UConnRCMPy is constructed in a hierarchical manner. The main user
interface to UConnRCMPy is through the \python|Condition| class, the
highest level of data representation. The \python|Condition| class
contains all of the information pertaining to the experiments at a given
condition. The intended use of this class is in an interactive Python
interpreter (the author prefers the Jupyter Notebook with an IPython
kernel \autocite{Perez2007}). \python|Condition| also contains all the
methods that make up the user interface:

\begin{itemize}
\item
  \python|add_experiment()|
\item
  \python|create_volume_trace()|
\item
  \python|compare_to_sim()|
\end{itemize}

The usage of these methods will be described in detail in the
\cref{usage-example} section. In general, the user will
conduct several experiments and, using the \python|add_experiment()|
method, will trigger UConnRCMPy to create instances of the
\python|Experiment| class and extract the ignition delay.

All of the information about a particular experimental run is stored in
the \python|Experiment| class. Information about the signal
measured from the DAQ is stored in an instance of the
\python|VoltageTrace| class, which reads the signal from a
tab-delimited text file. When an instance of \python|Experiment|
is initialized, it automatically creates an instance of
\python|VoltageTrace| followed by an instance of
\python|ExperimentalPressureTrace|. The pressure trace from the
latter is processed to extract the ignition delay(s) and \(P_C\).

When all the experiments are conducted and processed,
\python|create_volume_trace()| further processes the experiments to
create the volume trace necessary to run the simulations to determine
\(T_C\). After generation, \python|create_volume_trace()| writes
the volume trace out to a CSV file so that the volume trace can be used in
other software. The reactive pressure trace is also written to a tab-separated
file. Before writing, the volume and pressure traces are both
downsampled by a factor of 5. This reduces the computational time of a
simulation and does not have any effect on the simulated results.

The final step is to use the volume trace in a simulation to determine
\(T_C\). To begin the simulations, the user calls the
\python|compare_to_sim()| method of the
\python|Condition|.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/flowchart.pdf}
    \caption{Flowchart of information in \mbox{UConnRCMPy}}
    \label{fig:flowchart}
\end{figure}

The general flow of the user interaction with UConnRCMPy is shown in
\cref{fig:flowchart}. The Inputs are required input from the
user, while the User Interface are classes and functions called by the
user during processing.

UConnRCMPy is documented using standard Python docstrings for functions
and classes. The documentation is converted to HTML files by the Sphinx
documentation generator \autocite{Brandl2016}. The format of the
docstrings conforms to the NumPy docstring format so that the autodoc
module of Sphinx can be used. The documentation is available on the web
at \href{https://bryanwweber.github.io/UConnRCMPy/}.

\section{Usage Example}\label{usage-example}

The following example assumes the user is running a Jupyter Notebook with an
IPython kernel. These experiments were conducted with mixtures of propane,
oxygen, and nitrogen \autocite{Dames2016}. The CTI file necessary to run this
example can be found in the Supplementary Material of the work by
\textcite{Dames2016}. Then, the composition of the mixture under consideration
must be added to the \python|initial_state| parameter of the
\python|ideal_gas()| method:

\begin{minted}{python}
ideal_gas(
    name='gas', elements=..., species=..., reactions='all',
    initial_state=state(temperature=300.0, pressure=OneAtm,
        mole_fractions='C3H8:0.0403,O2:0.1008,N2:0.8589')))
\end{minted}

Ellipses indicate input that was truncated to save space; the truncated
input is present in the file available with the work of \textcite{Dames2016}. The
initial temperature and pressure are arbitrary, since those are set
based on information stored in the filename of the experiment, but the
\python|mole_fractions| must be set to the appropriate values. The
condition in this example is for a fuel rich mixture, with a target
\(P_C\) of 30 bar.

Once the thermodynamic information is set, the user initializes the
\python|Condition|, which has two optional arguments. The first is
\python|cti_file|, which can be assigned a string with the file name
of the CTI file with thermodynamic information. The default is a file named
\python|species.cti| in the current directory. The second argument,
\python|plotting|, controls whether plots are generated as analysis
is conducted. The default value of this argument is \python|True|.

After initializing the \python|Condition|, the user conducts a
reactive experiment with the RCM and adds the experiment to the
\python|Condition| using the \python|add_experiment()|
method. As each experiment is processed by UConnRCMPy, the information from
that run is added to the system clipboard for pasting into some spreadsheet
software. In the current version, the information copied is the time of day of
the experiment, the initial pressure, the initial temperature, the pressure at
the EOC, the overall and first stage ignition delays, an estimate of the EOC
temperature, some information about the compression ratio of the reactor, and
the filter frequnecy used.

\begin{minted}{python}
from uconnrcmpy import Condition
%matplotlib qt5

cond_00_in_02_mm = Condition(cti_file='./species.cti')
# Conduct reactive experiment #1 on the RCM
cond_00_in_02_mm.add_experiment('00_in_02_mm_373K-1282t-100x-19-Jul-15-1633.txt')
# ... add other reactive experiments
\end{minted}

In general, for a given condition, the user will conduct and process all
of the reactive experiments before conducting any non-reactive
experiments. Then, the user chooses one of the reactive experiments as
the reference experiment for the condition (i.e., the one whose ignition
delay(s) and \(T_C\) are reported) by inspection of the data in the
spreadsheet. The reference experiment is defined as the experimental run
whose overall ignition delay is closest to the mean overall ignition
delay among the experiments at a given condition. To select the
reference experiment, the user sets the \python|reactive_file|
attribute of the \python|Condition| instance. For this case, the
reference experiment is the run that took place at 16:33:

\begin{minted}{python}
cond_00_in_02_mm.reactive_file = '00_in_02_mm_373K-1282t-100x-19-Jul-15-1633.txt'
\end{minted}

If the user does not specify the \python|reactive_file| attribute,
they are prompted for the file name when the first non-reactive case is added.
Once the reference reactive experiment is selected, the user runs non-reactive
experiments at the same initial conditions as the reference experiment. The user
adds non-reactive experiments to the \python|Condition| by the same
\python|add_experiment()| method and UConnRCMPy automatically
determines whether the experiment is reactive or non-reactive.

\begin{minted}{python}
# Conduct non-reactive experiment #1 on the RCM
cond_00_in_02_mm.add_experiment('NR_00_in_02_mm_373K-1278t-100x-19-Jul-15-1652.txt')
\end{minted}

UConnRCMPy determines that this is a non-reactive experiment and
generates a new figure that compares the current non-reactive case with
the reference reactive case. For this particular example, the pressure traces
are shown in \cref{fig:ign-delay-def}. In this case, the non-reactive
pressure agrees very well with the reactive pressure and no further
experiments are necessary; in principle, any number of non-reactive
experiments can be conducted and added to the figure for comparison.
Since there is good agreement between the non-reactive and reactive
pressure traces, the user sets the \python|nonreactive_file| attribute of the
\python|Condition| instance.

\begin{minted}{python}
cond_00_in_02_mm.nonreactive_file = 'NR_00_in_02_mm_373K-1278t-100x-19-Jul-15-1652.txt'
\end{minted}

Once the non-reactive case is chosen, the \python|create_volume_trace()| method
can be run. This method requires three attributes to be set on the
\python|Condition| instance: \python|nonreactive_end_time|,
\python|reactive_end_time|, and \python|reactive_compression_time|. The value of
\python|nonreactive_end_time| controls the end time for volume trace generation,
and is typically set to \SI{400}{\ms}. The value of \python|reactive_end_time|
controls the length of the pressure trace stored in the output file, and is
typically chosen to be a few \si{\ms} longer than the ignition delay time.
Finally, the \python|reactive_compression_time| is the length of the compression
stroke. All of the values must be supplied in units of milliseconds. After
generating the volume trace, \python|create_volume_trace()| writes the
\python|volume.csv| file, the pressure trace file, and file called
\python|volume-trace.yaml|, which contains the values that were set for each
attribute.

The final step to conduct the simulations to calculate \(T_C\) and the simulated
ignition delay. This is done by the user by running the
\python|compare_to_sim()| function. This function takes two optional arguments,
\python|run_reactive| and \python|run_nonreactive|. These determine which
type(s) of simulation(s) should be conducted; by default,
\python|run_reactive| is \python|False| and \python|run_nonreactive| is
\python|True| because the reactive simulations may take substantial time
($\sim\SI{5}{\min}$). There is no restriction on combinations of values for the
arguments; either or both may be \python|True| or \python|False|.

\begin{minted}{python}
cond_00_in_02_mm.create_volume_trace()
cond_00_in_02_mm.compare_to_sim(run_reactive=True, run_nonreactive=True)
\end{minted}

\section{Conclusions and Future Work}\label{conclusions-and-future-work}

UConnRCMPy provides a framework to enable consistent analysis of RCM
data. Because it is open source and extensible, UConnRCMPy can help to
ensure that RCM data in the community can be analyzed in a reproducible
manner; in addition, it can be easily modified and used for data in any
format. In this sense, UConnRCMPy can be used more generally to process
any RCM experiments where the ignition delay is the primary output.

Future plans for UConnRCMPy include the development of a robust test suite to
prevent regressions and document correct usage of the framework, as well as the
development of a plugin architechture to allow easy implementation of
user-defined analysis features.

\section{Acknowledgements}\label{acknowledgements}

This paper is based on material supported by the National Science
Foundation under Grant No. CBET-1402231.

\printbibliography

\end{document}
